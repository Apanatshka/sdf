module coq-semantics/main

imports
  include/TemplateLang
  libstratego-gpp
  coq-semantics/Coq
  coq-semantics/Vernacular.pp.generated
  coq-semantics/Coq-parenthesize
  name-desugar
  lib/runtime/index/-
  lib/runtime/nabl/-
  names
  
rules
  
  generate-coq-semantics-partition:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"v")> path
    ; coq-file := <strip-annos; module-to-coq> ast
    with
       result := <parenthesize-Coq; prettyprint-CoqFile; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprint-example) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""

rules
  
  module-to-coq:
    ast -> Sent([sort*, const*])
    where
     	sort* := <collect-all( ?SDFSection('sorts(<id>))
    	                     + ?TemplateProduction(<id>, _, _)
    	                     + ?TemplateProductionWithCons(SortCons(<id>, _), _, _)
    	                     ); sorts-to-coq> ast
    ; const* := <collect-all(where(?TemplateProductionWithCons(_,_,_))); template-productions-to-coq> ast

rules // sorts
  
  sorts-to-coq:
    sort* ->
  	 [ Inductive(Ind([Induc("sorts", [], Type(Sort(Set())), ListDeclBar(cdec*))]))
  	 , Assumption(Assuption("Parameter", Term(["Ident"], Sort(Set()))))
  	 , Definition(Def("sort", [], None(), Ref("sorts")))
  	 , Definition(Def("Ident_Sort", [], None(), Ref("ID_S")))]
  	with
  	  cdec* := <map(sort-to-coq)> sort*
  	  
  sort-to-coq: // Waiting for more complex examples
    n -> ConsDecl($[[n]_S], [], None())

rules // Template productions (i.e. constructors)
  
  template-productions-to-coq:
    template* ->
     [ Inductive(Ind([Induc("Signames", [], None(), ListDeclBar(signame*))]))
     , Definition(Def("signames", [], None(), Ref("Signames")))
     , Fixpoint(
         Fixpoint(
           [
             FixBody(
	             "get_sig"
	           , [ Binds(["x"], Ref("signames")) ]
	           , None()
	           , None() // Type(Prod... Apply... list sort * sort etc)
	           , Match(
	               [ MatchItem(
	                   Ref("x")
	                 , None()
	                 , None())
	               ]
	             , None()
	             , eq*
	             )
	           )
           ]
         )
       )
     ]
     where
       eq* := <map(template-production-to-coq)> template*
     ; signame* := <map(\ Eq([[x]],_) -> ConsDecl(x, [], None()) \)> eq*
  
  template-production-to-coq:
    TemplateProductionWithCons(SortCons(s,c),Template(template*),_) -> eq
    where
      template-cdec := <template-to-coq> template*
    ; eq :=
      Eq(
        [[c]]
      , Apply(
          Apply(
            Ref("pair")
          , template-cdec
          )
        , Ref(s)
        )
      )
  
  template-to-coq =
  	  collect-all(?Placeholder(None(), sort(<id>), None(), NoOptions()))
    ; map(!Apply(Ref("cons"), Ref(<id>)))
    ; !(<id>, Ref("nil"))
    ; foldl(\ (x,y) -> Apply(x, y) \ )