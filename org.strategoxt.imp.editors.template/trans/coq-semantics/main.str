module coq-semantics/main

imports
  src-gen/signatures/-
  src-gen/signatures/modules/-
  src-gen/signatures/sorts/-
  libstratego-gpp
  lib/Coq/-
  lib/Coq/pp/-
  lib/Coq/signatures/-
  lib/runtime/index/-
  lib/runtime/nabl/-
  analysis/names
  coq-semantics/skeleton
  
rules
  
  generate-coq-concrete:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := "src-gen/verification/syntax.v"
    ; coq-file := <strip-annos; module-to-coq(|"syntax")> ast
    with
       result := <parenthesize-Coq; prettyprintCoq-CoqFile; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprintCoq-example) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""
  
  generate-coq-abstract:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := "src-gen/verification/syntax.aterm"
    ; result := <strip-annos; module-to-coq(|"syntax")> ast

rules
  
  module-to-coq(|filename):
    Module(Unparameterized(name), imps, ast) -> <build-module(|filename)> (sort, constr, get_sig)
    where
     	sort := <collect-all( ?TemplateProduction(<id>, _, _)
    	                    + ?TemplateProductionWithCons(SortCons(<id>, _), _, _)
    	                    ); sorts-to-coq> ast
    ; (constr, get_sig) := <collect-all(where(?TemplateProductionWithCons(_,_,_))); template-productions-to-coq> ast
    
rules // sorts
  
  sorts-to-coq:
    sort* -> S|[Inductive sorts : Set := decls.]|
  	with
  		defs* := [ D|[ID_S]|, D|[INT_S]| ]
  	; decls := <map(sort-to-coq); ![defs* | <id>]; nub; !ListDeclBar(<id>)> sort*
  	  
  sort-to-coq:
    SortDef(n) -> ConsDecl($[[n]_S], None(), None())

rules // Template productions (i.e. constructors)
  
  template-productions-to-coq:
    template* ->
      (
      	S|[Inductive Constructors : Set := decl_constr.]|,
      	S|[Fixpoint get_sig (x: constructors) : ((list sort), sort) := match x with equations_match end. ]|
      )
     where
       equations       := <map(template-production-to-coq)> template*
     ; decl_constr     := <map(\ Eq([[ident_x]],_) -> D|[ident_x]| \);
                          !ListDeclBar([D|[INTC (n: nat)]| | <id>])> equations
     ; intc_eq         := Eq([[QidPattern("INTC", ["n"])]], T|[([],INT_S)]|)
     ; equations_match := ListEqBar([intc_eq | equations])
  
  template-production-to-coq:
    TemplateProductionWithCons(SortCons(SortDef(s),Constructor(c)),TemplateSquare(template*),_) -> eq
    where
      term_template := <collect-all(?Placeholder(Sort(<id>),_); !Ref( $[[<id>]_S] )); !List(<id>)> template*
    ; ident_return  := $[[s]_S]
    ; eq :=
      Eq(
        [[ $[[c]C] ]]
      , T|[(term_template, ident_return)]|
      )
  