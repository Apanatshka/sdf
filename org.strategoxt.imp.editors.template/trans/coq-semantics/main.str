module coq-semantics/main

imports
  include/TemplateLang
  libstratego-gpp
  coq-semantics/Coq
  coq-semantics/Vernacular.pp.generated
  coq-semantics/Coq-parenthesize
  lib/runtime/index/-
  lib/runtime/nabl/-
  analysis/names
  
rules
  
  generate-coq-concrete:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"v")> path
    ; coq-file := <strip-annos; module-to-coq> ast
    with
       result := <parenthesize-Coq; prettyprint-CoqFile; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprint-example) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""
  
  generate-coq-abstract:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"coq.aterm")> path
    ; result := <strip-annos; module-to-coq> ast

rules
  
  module-to-coq:
    ast -> Sent([sort*, const*])
    where
     	sort* := <collect-all(?Sort(<id>)
    	                     + ?TemplateProduction(<id>, _, _)
    	                     + ?TemplateProductionWithCons(SortCons(<id>, _), _, _)
    	                     ); nub; sorts-to-coq> ast
    ; const* := <collect-all(where(?TemplateProductionWithCons(_,_,_))); template-productions-to-coq> ast

rules // sorts
  
  sorts-to-coq:
    sort* ->
  	 [ Inductive(Ind([Induc("sorts", [], Type(Sort(Set())), ListDeclBar(cdec*))]))
  	 , Assumption(Assuption("Parameter", Term(["Ident"], Sort(Set()))))
  	 , Definition(Def("sort", [], None(), Ref("sorts")))
  	 , Definition(Def("Ident_Sort", [], None(), Ref("ID_S")))]
  	with
  	  cdec* := <!["ID", "INT" | <id>]; nub; map(sort-to-coq)> sort*
  	  
  sort-to-coq: // Waiting for more complex examples
    n -> ConsDecl($[[n]_S], [], None())
    where <is-string> n

rules // Template productions (i.e. constructors)
  
  template-productions-to-coq:
    template* ->
     [ Inductive(Ind([Induc("Constructors", [], None(), ListDeclBar([def-signame*, signame*]))]))
     , Definition(Def("constructors", [], None(), Ref("Constructors")))
     , Fixpoint(
         Fixpoint(
           [
             FixBody(
	             "get_sig"
	           , [ Binds(["x"], Ref("constructors")) ]
	           , None()
	           , Type(
                 Apply(
				           Apply(Ref("prod"), Apply(Ref("list"), Ref("sort")))
				         , Ref("sort")
				         )
				       )
	           , Match(
	               [ MatchItem(
	                   Ref("x")
	                 , None()
	                 , None())
	               ]
	             , None()
	             , ListEqBar([def-const*, eq*])
	             )
	           )
           ]
         )
       )
     ]
     where
       eq* := <map(template-production-to-coq)> template*
     ; signame* := <map(\ Eq([[x]],_) -> ConsDecl(x, [], None()) \)> eq*
     ; def-const* := [
         Eq(
           [[QidPattern("INTC", ["n"])]]
         , Apply(Apply(Ref("pair"), Ref("nil")), Ref("INT_S"))
         )
       ]
     ; def-signame* := [
	       ConsDecl(
           "INTC"
         , [Binds(["n"], Ref("nat"))]
         , None()
         )
       ]
  
  template-production-to-coq:
    TemplateProductionWithCons(SortCons(s,c),Template(template*),_) -> eq
    where
      template-cdec := <mapconcat(?Line(<id>)); template-to-coq> template*
    ; eq :=
      Eq(
        [[ $[[c]C] ]]
      , Apply(
          Apply(
            Ref("pair")
          , template-cdec
          )
        , Ref( $[[s]_S] )
        )
      )
  
  template-to-coq =
  	  filter(?Placeholder(<id>,_))
    ; map(!Apply(Ref("cons"), Ref( $[[<id>]_S] )))
    ; foldr(!Ref("nil"), \ (x,y) -> Apply(x, y) \ )