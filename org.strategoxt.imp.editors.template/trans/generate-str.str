module generate-str
imports
  libstratego-lib
  include/Template
  analysis
  desugar
  generation-utils
  sdf2conflicts

strategies

  to-str(|modulename):
    Module(_, _, _) ->
    $[module [modulename]
      imports
        libstratego-lib

      strategies

        pp-option(s) = \None() -> ""\ + \Some(t) -> <s> t\
        pp-list(s|t) = map(s); separate-by(|t); concat-strings

        [ih]

      [section*]

      strategies // all other sorts used in placeholders

        [strategy*]]
    with
      // all imported modules
      module*  := <all-keys-IsImported; map(Module)>;
      section* := <map(to-str-module); separate-by(|"\n\n")>
    with
      // All sorts used in pp minus all sorts for which a pp strategy has been
      // created will get a `prettyprint-sort = is-string' default strategy.
      sorts-used-in-pp := <collect-om(sort-used-in-prettyprinting); nub> module*;
      sorts-decl-in-pp := <collect-om(sort-decl-in-prettyprinting); nub> module*;
      sorts-without-pp := <diff> (sorts-used-in-pp, sorts-decl-in-pp);
      strategy* := <map(sort-to-prettyprint-strategy); separate-by(|"\n\n")> sorts-without-pp
    with
      ih := <newlines-switch(
        // No newlines: need to prepend a newline+indent if the string is non-empty.
        !$[// ih = indent helper, t = indent string (including "\n")
           pp-ih(|t) = "" <+ string-replace(|"\n", t); <conc-strings> (t, <id>)],
        // Leading newlines: easy, since indent is (per definition) also leading.
        !$[// ih = indent helper, t = indent string (including "\n")
           pp-ih(|t) = "" <+
             string-replace(|"\n", t);
             if not(string-starts-with(|t)) then
               <conc-strings> (t, <id>)
             end],
        // Trailing newlines: harder, since indent and newline are separated.
        !$[// ih = indent helper, t = indent string (excluding "\n")
           pp-ih(|t) = "" <+ all-lines(<conc-strings>(t, <id>))]
      )>

  to-str:
    Module(modulename, _, _) -> <to-str(|modulename)>

  to-str-module:
    m@ Module(modulename, _, _) ->
    $[strategies // [modulename]

        [strategy*]]
    with
      strategy* := <collect-om(template-to-prettyprint-strategy); separate-by(|"\n\n")>

strategies

  sort-to-prettyprint-strategy:
    sort -> $[prettyprint-[sort] = is-string]

  sort-decl-in-prettyprinting:
    TemplateProduction(sort, Template(_), _) -> sort

  sort-used-in-prettyprinting:
    Placeholder(_, Sort(sort), _, _) -> sort

  // Optimization for single-string-element templates
  template-to-prettyprint-strategy:
    TemplateProduction(sort, Template([String(t)]), attr*) ->
    $[prettyprint-[sort]:
        [cons]() -> [result]]
    where
      cons   := <collect-one(?sdf-cons(<un-double-quote>))> attr*
    with
      result := <escape-and-double-quote> t

  template-to-prettyprint-strategy:
    TemplateProduction(sort, Template(elem*), attr*) ->
    <trim-chars(' ' + '\t' + '\r' + '\n')> // Workaround Stratego/856
    $[prettyprint-[sort]:
        [cons]([arg'*]) -> zz
        with
          [let'*]]
    where
      not(!elem* => [String(_)])
    where
      cons    := <collect-one(?sdf-cons(<un-double-quote>))> attr*
    with
      elem'*  := <try-re-indent;
                  !(<id>, 0);
                  thread-map(try(rename-template-element));
                  ?(<id>, _)> elem*;
      arg*    := <filter(template-element-to-cons-arg)> elem'*;
      arg'*   := <separate-by(|", ")> arg*;
      part*   := <newlines-switch(trim-layout, trim-trailing-layout,
                                  trim-leading-layout ; trim-trailing-indent);
                  listtd(template-element-to-stratego);
                  concatenate-consecutive-strings;
                  map(try(?String(<escape-and-double-quote>)));
                  separate-by(|", ")> elem'*;
      result  := <concat-strings>["zz := <concat-strings> [", part*, "]"];
      confl*  := <bagof-SubtermConflicts> Symbol(cons, <length> arg*);
      if !confl* => [] then
        let*  := <filter(template-element-to-assignment)> elem'*
      else
        let*  := <filter(?Placeholder(_, _, _, _));
                  add-indices;
                  filter(template-element-to-parenthesize(|confl*))> elem'*
      end;
      let'*   := <separate-by(|";\n")> [let*, result]

  // Production without cons but with bracket annotation
  // (cons + bracket -> no need to parenthesize)
  template-to-prettyprint-strategy:
    TemplateProduction(sort, Template(elem*), attr*) ->
    ${parenthesize-{sort}(not-allowed) =
        if not-allowed then
          <concat-strings> ["{open}", <prettyprint-{sort}>, "{close}"]
        else
          prettyprint-{sort}
        end}
    where
      not(<collect-one(?sdf-cons(<un-double-quote>))> attr*);
      <collect-one(?bracket())> attr*
    where
      <length> <filter(?Placeholder(_, _, _, _))> elem* => 1
      <+ debug(!"Bracket production must have exactly one placeholder: "); fail
    with
      (before, placeholder, after) := <split-fetch-keep(?Placeholder(_, _, _, _))> elem*
    where
      [String(open)]  := <map(template-element-to-stratego'); concatenate-consecutive-strings> before;
      [String(close)] := <map(template-element-to-stratego'); concatenate-consecutive-strings> after
      <+ debug(!"Bracket production must have text before and after the placeholder: "); fail

  rename-template-element:
    (Placeholder(a, b@ Sort(x), c, d){a*}, index) -> (Placeholder(a, b{newname}, c, d){a*}, newindex)
    with
      newname  := <implode-string> [<addi> ('a', index)];
      newindex := <inc> index

  template-element-to-cons-arg:
    Placeholder(_, Sort(_){name}, _, _) -> name

  template-element-to-stratego =
    newlines-switch(
      // No newlines
      \[Newline(_), Indent(indent), Placeholder(_, Sort(_){name}, _, _){Blank()} | tail] ->
        [$[<pp-ih(|"\n[indent]")> [name]'] | tail]\,
      // Leading newlines
      \[Newline(_), Indent(indent), Placeholder(_, Sort(_){name}, _, _){Blank()} | tail] ->
        [$[<pp-ih(|"\n[indent]")> [name]'] | tail]\,
      // Trailing newlines
      \[Indent(indent), Placeholder(_, Sort(_){name}, _, _){Blank()}, Newline(_) | tail] ->
        [$[<pp-ih(|"[indent]")> [name]'] | tail]\
    )
    // Anything else.
    <+
      [template-element-to-stratego' | id]
    <+
      []

  template-element-to-stratego' =
      \Placeholder(_, Sort(_){name}, _, _) -> $[[name]']\
    + \String(t) -> String(t)\
    + \Layout(t) -> String(t)\
    + \Indent(t) -> String(t)\
    + \Newline(t) -> String(t)\

  template-element-to-assignment:
    Placeholder(_, Sort(x){name}, None(), _) -> $[[name]' := <prettyprint-[x]> [name]]

  template-element-to-assignment:
    Placeholder(_, Sort(x){name}, <Star() + Plus()>, Options(opt*)) -> t
    with
      if sep := <collect-one(?Separator(<id>))> opt* then
        t := $[[name]' := <pp-list(prettyprint-[x]|"[<escape> sep]")> [name]]
      else
        t := $[[name]' := <pp-list(prettyprint-[x]|" ")> [name]]
      end

  template-element-to-assignment:
    Placeholder(_, Sort(x){name}, Option(), _) -> $[[name]' := <pp-option(prettyprint-[x])> [name]]

  template-element-to-parenthesize(|conflicts):
    (i1, Placeholder(_, Sort(x){name}, None(), _)) -> $[[name]' := <parenthesize-[x]([na])> [name]]
    with
      i0 := <dec> i1;
      let subterm-conflict-to-match = {x, n, a*:
            ( (i0, Symbol(x, n)) -> <concat-strings> ["?", x, "(", a*, ")"]
              with a* := <range; map(!"_"); separate-by(|", ")> (0, n) )
          }
      in
        na := <filter(subterm-conflict-to-match);
               separate-by(|" + ");
               try(\ [] -> ["fail"] \)> conflicts
      end
