module generation-utils
imports
  libstratego-lib
  lib/editor-common.generated
  include/Template
  analysis

signature
  constructors
    // Options
    Newlines : X
    ImportPath : X
    EsvOutput : X
    SdfOutput : X
    StrOutput : X
    // Other
    Indent : String -> Indent

strategies // Utility strategies

  add-anno(|anno):
    x{a*} -> x{anno, a*}

  has-anno(|anno):
    x{a*} -> <id>
    where <one(?anno)> a*

  // is-layout is already defined somewhere else
  xxx-is-layout = ?Layout(_) + ?Indent(_) + ?Newline(_)

  trim-leading-layout =
    ltrim(xxx-is-layout)

  trim-trailing-layout =
    rtrim(xxx-is-layout)

  trim-trailing-indent =
    rtrim(?Indent(_))

  trim-layout =
    trim-leading-layout;
    trim-trailing-layout

  // origin-column (obviously) doesn't work in an imported file...
  // get-indent-string =
  //   filter(not(?Layout(_) + ?Newline(_)); origin-column); list-min => size;
  //   // Build string from right to left, as list.
  //   ![]; repeat(![' ' | <id>] | size); !['\n' | <id>];
  //   implode-string

  // This doesn't take the indentation due to everything up to
  // the open brackets of the template into account.
  get-indent-string =
    let get-indent =
             \[Newline(_), Layout(y), _ | tail] -> [<string-length> y | <get-indent> tail]\
          <+ \[Newline(_), Layout(_)] -> []\
          <+ \[Newline(_), Newline(_) | tail] -> <get-indent> tail\
          <+ \[Newline(_), y | tail] -> [0 | <get-indent> tail]\
          <+ \[_ | tail] -> <get-indent> tail\
          <+ []
    in
      get-indent; list-min => size;
      // Build string from right to left, as list.
      ![]; repeat(![' ' | <id>] | size); !['\n' | <id>];
      implode-string
    end

  re-indent(|indent-string) =
    \[Newline(_), Layout(indent) | tail] -> result
    with
      // Add a newline because indent-string contains a newline as anchor.
      indent' := <string-replace(|indent-string, "")> <conc-strings>("\n", indent);
      tail' := <re-indent(|indent-string)> tail;
      result := [Newline("\n"), Indent(indent') | tail']\
  <+
    \[head | tail] -> [head | <re-indent(|indent-string)> tail]\
  <+
    []

  try-re-indent =
    if get-indent-string => is then
      re-indent(|is)
    end

  normpath =
    ?original;
    string-tokenize(|['/', '\']);
    filter(not("."));
    repeat(   rec x( \[_, ".." | t] -> t\ <+ [id | x] ) // remove one "dir/.." pair
           <+ \[".." | t] -> t\ );                      // remove leading ".."
    separate-by(|"/");
    if <is-abspath> original then  // FIXME: is-abspath may be POSIX-only?
      !["/" | <id>]
    end;
    concat-strings

  concatenate-consecutive-strings =
       \[String(a), String(b) | tail] -> <concatenate-consecutive-strings> [String(<conc-strings> (a, b)) | tail]\
    <+ [id | concatenate-consecutive-strings]
    <+ []

  combine-consecutive-newlines =
       \[Newline(x){a*}, Newline(_){b*} | tail] -> <combine-consecutive-newlines> [Newline(x){a*, b*} | tail]\
    <+ [id | combine-consecutive-newlines]
    <+ []

  escape-and-double-quote =
    string-replace(|"\t", "\\t");
    string-replace(|"\r", "\\r");
    string-replace(|"\n", "\\n");
    string-replace(|"'", "\\'");
    string-replace(|"\"", "\\\"");
    double-quote

strategies // Options

  use-no-newlines       = <Options> Newlines() => None()
  use-leading-newlines  = <Options> Newlines() => Leading()
  use-trailing-newlines = <Options> Newlines() => Trailing()

  newlines-switch(none, leading, trailing) =
    switch <Options> Newlines()
      case ?None(): none
      case ?Leading(): leading
      case ?Trailing(): trailing
    end

  get-esv-output-path = <Options> EsvOutput()
  get-sdf-output-path = <Options> SdfOutput()
  get-str-output-path = <Options> StrOutput()
