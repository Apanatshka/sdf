module generation/to-sdf

imports
  libstratego-lib
  libstratego-sglr
  utils/contract
  
  include/TemplateLang
  analysis/attributes
  analysis/names
  runtime/nabl/-
  runtime/task/-
  runtime/properties/-
  
  generation/tokenize
  
rules
	
	get-def-improved = 
	   get-property-task(|NablProp_def())
   ; insert-results // TODO: is this the right insertion?
  <+ try(nabl-get-name)
   ; nabl-uris // TODO: how to handle multiple values?
   ; mapconcat(!Prop(<id>, NablProp_def(), ()); nabl-get-all-values; insert-results; concat)

  pack-sdf = MkSingleton ; !definition(<pack-sdf(|[])>)
  
  pack-sdf(|seen) = ?[]
  
  pack-sdf(|seen):
  	[ m @ 'module(mn, i*, _) | m* ] -> result
  	where
  		if <elem> (mn, seen) then
  		  result := <pack-sdf(|seen)> m*
      else
      	im*    := <mapconcat(?imports(<mapconcat(get-def-improved)>))> i*
      ;	m'*    := <pack-sdf(|[mn|seen])> [m*, im*]
      ; result := [<module-to-sdf> m, m'*]
      end
  			    
  module-to-sdf =
  	'module(id, id, !exports(<sections-to-sdf>))
  	
  /** @type List(TemplateSection | ...) -> List(grammar) */
  sections-to-sdf =
    where (chars := <collect-one(?Tokenize(<id>)) <+ !['(', ')']>)
  ; where (kfr   := <collect-one(?KeywordFollowRestriction(<id>) <+ !None())>)
  ; where (nl    := <collect-one(?Newlines(<id>) <+ !None())>)
  ; filter(section-to-sdf(|chars, kfr, nl))
  ; concat

rules

  /** @type TemplateSection -> grammar */
  section-to-sdf(|chars, kfr, nl):
    TemplateSection(t*) -> [context-free-syntax(p*), inj*, restr*]
    where with-spxverify(
      p* := <map(template-production-to-sdf(|chars, kfr, nl))> t*;
      // content complete productions
      p'* := < map(?TemplateProduction(<id>, _, _, _))
             ; nub
             ; map(sort-to-contentcomplete)> t*;
      if !p'* => [] then
        inj* := []
      else
        inj* := [context-free-syntax(p'*)]
      end;

      // lexical restrictions
      let chars-end-with-identifier-char =
            where(reverse; ?[<is-alphanum + '_'> | _])

          string-ends-with-identifier-char =
            where(explode-string; chars-end-with-identifier-char)
      in
        r* := <collect-om(?String(<string-ends-with-identifier-char>));
               filter(string-to-sdf(|chars); last)> t*;
        if !r* => [] + !kfr => None() then
          restr* := []
        else
          restr* := [lexical-restrictions([follow(r*, kfr)])]
        end
      end
      , !"Failed to convert TemplateSection to SDF"
    )

  template-production-to-sdf(|chars, kfr, nl):
    TemplateProduction(s, c, t, attrs) -> prod(sym*, s, attrs')
    where with-spxverify (
      sym* := <template-to-sdf(|chars, kfr, nl)> t
    ; attr1* := <cons-to-attrs> c
    ; attr2* := <get-attrs; remove-all(?sdf-completion(_))> attrs
    ; attrs' := <set-attrs> [attr1*, attr2*]
    )

rules
	
  section-to-sdf(|chars, kfr, nl):
    SDFSection(x) -> [<alltd(sdf-production-to-sdf + priority-group-to-sdf(|chars, kfr, nl))> x]

  sdf-production-to-sdf:
    SdfProduction(sort, cons, Rhs(symbol*), attrs) ->
      prod(symbol*, sort(sort), attrs')
    where with-spxverify(
      attr1* := <cons-to-attrs> cons
    ; attr2* := <get-attrs> attrs
    ; attrs' := <set-attrs> [attr1*, attr2*] 
    )

  priority-group-to-sdf(|chars, kfr, nl):
    simple-ref-group(ref) -> prods-group(<sort-cons-to-prods(|chars, kfr, nl)> ref)

  priority-group-to-sdf(|chars, kfr, nl):
    prods-ref-group(ref*) -> prods-group(<mapconcat(sort-cons-to-prods(|chars, kfr, nl))> ref*)

  priority-group-to-sdf(|chars, kfr, nl):
    assoc-ref-group(a, ref*) -> assoc-group(a, <map(sort-cons-to-prods(|chars, kfr, nl))> ref*)

  sort-cons-to-prods(|chars, kfr, nl) =
     ?SortCons(s, c) 
   ; get-def-improved
   ; (is-list <+ MkSingleton)
   ; map(
       ?SdfProduction(_, _, Rhs(<id>), _)
     + ?TemplateProduction(_, _, <template-to-sdf(|chars, kfr, nl)>, _)
     )
   ; map(!prod(<id>, sort(s), no-attrs()))

rules
	
  cons-to-attrs =
    (Inj() -> []) <+ ![sdf-cons(<double-quote>)]
  
  get-attrs =
    (no-attrs() -> []) + ?attrs(<id>)
 
  set-attrs =
    ([] -> no-attrs()) <+ !attrs(<id>)

  // Single line template.
  //  -OR-
  // Template with only a placeholder. (i.e., injection)
  // The placeholder is at the start AND at the end of the template!
  template-to-sdf(|chars, kfr, nl):
    < ?SingleLineTemplate(elem*)
    + ?Template([Line(elem* @ [Layout(_), Placeholder(label, _, _, _)])]) > -> A*
    where with-spxverify (
      A* := <maybe-separating(
               filter(template-element-to-sdf-sep <+ template-element-to-sdf(|chars))
             , filter(template-element-to-sdf(|chars))
             | kfr
             );
             flatten-list> elem*
    )

  // Multi line template.
  template-to-sdf(|chars, kfr, nl):
    Template(line*) -> A*
    where with-spxverify (
      A* := <filter(?Line([Layout(_), _ | _]));
             maybe-separating(
               !(<id>, 0); thread-map(template-line-to-sdf-sep(|chars)); ?(<id>, _)
             , map(template-line-to-sdf(|chars, nl))
             | kfr
             );
             flatten-list> line*
    )
    
  maybe-separating(yes, no|kfr) =
    if !kfr => Separating() then yes else no end

rules

  template-line-to-sdf-sep(|chars):
    (Line([Layout(_), p @ Placeholder(label, sort(S), mult, option*)]), state) ->
      (result, state)
    where
      <one(Separator(is-substring(!"\n")))> option*
    where
      L := "\"\\n\"";
      switch !(mult, state)
        case ?(None()  , 0) : result := A|[ (S L)  ]|
        case ?(Option(), 0) : result := A|[ (S L)? ]|
        case ?(Star()  , 0) : result := A|[ (S L)* ]|
        case ?(Plus()  , 0) : result := A|[ (S L)+ ]|
        case ?(None()  , 1) : result := A|[ (L S)  ]|
        case ?(Option(), 1) : result := A|[ (L S)? ]|
        case ?(Star()  , 1) : result := A|[ (L S)* ]|
        case ?(Plus()  , 1) : result := A|[ (L S)+ ]|
      end

  template-line-to-sdf-sep(|chars):
    (Line(elem*), 0) -> (<template-line-to-sdf-sep-helper(|chars)> elem*, 1)

  template-line-to-sdf-sep(|chars):
    (Line(elem*), 1) ->
      ([ A|[ "\"\\n\"" ]| | <template-line-to-sdf-sep-helper(|chars)> elem*], 1)

  template-line-to-sdf-sep-helper(|chars) =
    not(?[Layout(_), Placeholder(label, _, _, <one(Separator(is-substring(!"\n")))>)]);
    filter(template-element-to-sdf-sep <+ template-element-to-sdf(|chars))

  template-element-to-sdf-sep:
    Placeholder(label, sort(S), Star(), option*) -> A|[ {S "\"\\n\""}* ]|
    where <one(Separator(is-substring(!"\n")))> option*

  template-element-to-sdf-sep:
    Placeholder(label, sort(S), Plus(), option*) -> A|[ {S "\"\\n\""}+ ]|
    where <one(Separator(is-substring(!"\n")))> option*

rules

  template-line-to-sdf(|chars, nl) =
    ?Line(<id>);
    if not(?[Layout(_), Placeholder(label, _, _, _)]) then
      switch !nl
        case ?None()     : id
        case ?Leading()  : ![String("\n") | <id>]
        case ?Trailing() : (elem* -> [elem*, String("\n")])
      end
    end;
    filter(template-element-to-sdf(|chars))

  template-element-to-sdf(|chars):
    String(x) -> <string-to-sdf(|chars)> x

  template-element-to-sdf(|chars):
    Placeholder(None(), sort(S), None(), _) -> A|[ S ]|

  template-element-to-sdf(|chars):
    Placeholder(Label(l), sort(s), None(), _) -> label(unquoted(l), sort(s))

  template-element-to-sdf(|chars):
    Placeholder(label, sort(S), Option(), _) -> A|[ S? ]|

  template-element-to-sdf(|chars):
    Placeholder(label, sort(S), Star(), option*) -> A|[ S* ]|
    where <not(one(Separator(not(string-is-layout))))> option*

  template-element-to-sdf(|chars):
    Placeholder(label, sort(S), Star(), option*) -> A|[ { S L }* ]|
    where <one(Separator(not(string-is-layout)))> option*
    where with-spxverify ( L := <separator-to-literal> option*)

  template-element-to-sdf(|chars):
    Placeholder(label, sort(S), Plus(), option*) -> A|[ S+ ]|
    where <not(one(Separator(not(string-is-layout))))> option*

  template-element-to-sdf(|chars):
    Placeholder(label, sort(S), Plus(), option*) -> A|[ { S L }+ ]|
    where <one(Separator(not(string-is-layout)))> option*
    where with-spxverify( L := <separator-to-literal> option*  )

  char-is-layout =
    ' ' + '\t' + '\r' + '\n'

  string-is-layout =
    string-as-chars(all(char-is-layout))

  remove-layout =
    string-as-chars(filter(not(char-is-layout)))

  separator-to-literal =
    getfirst(?Separator(<remove-layout; templatelang-escape; double-quote>))

  sort-to-contentcomplete:
    S -> p|[ CONTENTCOMPLETE -> S {cons(L)} ]|
    where
      L := $["COMPLETION-[S]"]

strategies

  /**
   * Sorts a list of terms on the outermost string within each term.
   */
  string-sort-ex =
    qsort(<string-lt> (<collect-one(is-string)>, <collect-one(is-string)>))

  /**
   * Split on the edges delimiting identifiers.
   * E.g. "func(x,y)" => ["func", "(", "x", ",", "y", ")"]
   */
  string-to-sdf(|chars) =
    string-edge-tokenize(where({x: ?x; <one(?x)> chars}));
    // FIXME: Case insensitive literals need ci-lit/single-quote.
    map(!lit(<templatelang-escape; double-quote>))

  templatelang-escape =
    string-replace(|"\\", "\\\\");
    string-replace(|"\t", "\\t");
    string-replace(|"\r", "\\r");
    string-replace(|"\n", "\\n");
    string-replace(|"'", "\\'");
    string-replace(|"\"", "\\\"")

  create-def-task(|ctx) = ?SortCons(_, <def-lookup(|ctx)>)
  create-def-task(|ctx) = ?'module(unparameterized(<def-lookup(|ctx)>))
    