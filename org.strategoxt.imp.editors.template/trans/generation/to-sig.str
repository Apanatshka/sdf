module to-sig

imports
  libstratego-lib
  libstrc
  include/TemplateLang
  utils/contract
  analysis/types
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  
  generation/to-str
  
rules
	
	module-to-sig:
		'module(unparameterized(m), i*, s*) -> Module(m', [is*, s'])
		with
			m'  := <conc-strings> (m, ".sig")
		; is* := <map(to-str-import(|".sig"))> i*
	  ; s'  := Signature(<filter(section-to-sig)> s*)
 
  section-to-sig:
  	SDFSection('sorts(s*)) -> Sorts(s'*)
  	with
  		s'* := <map(sort-to-sig)> s*
  		
  section-to-sig:
    SDFSection(lexical-syntax(p*)) -> Constructors(sig*)
    where
      sig* := <filter(lexical-to-sig); not(?[])> p*
    
  section-to-sig:
    SDFSection(context-free-syntax(p*)) -> Constructors(sig*)
    where
      sig* := <filter(cfg-to-sig); not(?[])> p*
  
  section-to-sig:
    TemplateSection(t*) -> Constructors(sig*)
    with
      sig* := <filter(template-to-sig); not(?[])> t*
  
  sort-to-sig:
    sort(s) -> SortNoArgs(s)
  
  lexical-to-sig:
    SdfProduction(s, _, _, attrs(a*)) -> OpDeclInj(FunType([SortType("String")], SortType(s)))
    where
      <not(fetch-elem(?reject()))> a*
    
  cfg-to-sig:
  	SdfProduction(_, c, _, attrs(a*)) -> <cons-to-decl> c
    where
    	<not(fetch-elem(?reject() + ?bracket()))> a*
  
  template-to-sig:
    TemplateProduction(_, c, _, attrs(a*)) -> <cons-to-decl> c
    where
      <not(fetch-elem(?reject() + ?bracket()))> a*
  
  cons-to-decl:
    Inj() -> OpDeclInj(t)
    with
      t := <get-type; try(check-fun-type)>
  
  cons-to-decl:
    Constr(c) -> OpDecl(c, t)
    with
      t := <get-type; try(check-fun-type)> c
     
  check-fun-type: FunType([], t) -> t
  