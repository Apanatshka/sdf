module to-sig

imports
  libstratego-lib
  libstrc
  include/TemplateLang
  utils/contract
  analysis/types
  runtime/nabl/-
  runtime/task/-
  runtime/types/-
  
  generation/to-str
  
rules
	
	module-to-sig:
		'module(unparameterized(m), i*, s*) -> Module(m', [is*, s'])
		with
			m'  := <conc-strings> (m, ".sig")
		; is* := <map(to-str-import(|".sig"))> i*
	  ; s'  := Signature(<filter(section-to-sig)> s*)
 
  section-to-sig:
  	SDFSection('sorts(s*)) -> Sorts(s'*)
  	with
  		s'* := <map(sort-to-sig)> s*
  		
  section-to-sig:
    SDFSection(lexical-syntax(p*)) -> Constructors(sig*)
    where
      sig* := <filter(lexical-to-sig); not(?[])> p*
    
  section-to-sig:
    SDFSection(context-free-syntax(p*)) -> Constructors(sig*)
    where
      sig* := <filter(cfg-to-sig); not(?[])> p*
  
  section-to-sig:
    TemplateSection(t*) -> Constructors(sig*)
    with
      sig* := <map(template-to-sig)> t*
  
  sort-to-sig:
    sort(s) -> SortNoArgs(s)
  
  lexical-to-sig:
    SdfProduction(s, _, _, attrs) -> OpDeclInj(FunType([SortType("String")], SortType(s)))
    where
      <not(attrs(fetch-elem(reject())))> attrs
    
  cfg-to-sig:
  	SdfProduction(_, c, _, attrs) -> <cons-to-decl> c
    where
    	<not(attrs(fetch-elem(reject())))> attrs
    
  template-to-sig:
    TemplateProduction(_, c, _, _) -> <cons-to-decl> c  
  		
  cons-to-decl =
    ?Inj() 
  < !OpDeclInj(<get-type; try(?FunType([], <id>))>)
  + !OpDecl(<id>, <get-type; try(?FunType([], <id>))>)
  
  
    
  