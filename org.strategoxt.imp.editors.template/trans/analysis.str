module analysis
imports
  libstratego-lib
  include/Template
  include/Template-Signatures
  lib/editor-common.generated
  desugar
  generation-utils

signature
  constructors
  	Blank : Blank

strategies

  analyze:
    (ast, path, project-path) -> ast'
    with
      current-file := $[[project-path]/[path]];
      rules(
        CurrentFile := current-file
        IsImported  :  current-file
        ProjectDir  := project-path
      )
    with // default options
      esv-output-path := <guarantee-extension(|"esv")> current-file;
      sdf-output-path := <guarantee-extension(|"def")> current-file;
      str-output-path := <guarantee-extension(|"str")> current-file;
      rules(
        Options :+ Newlines() -> None()
        Options :+ ImportPath() -> "."
        Options :+ EsvOutput() -> esv-output-path
        Options :+ SdfOutput() -> sdf-output-path
        Options :+ StrOutput() -> str-output-path
      )
    with
      <debug(!"Analyzing: ")> current-file
    with
      ast' := <desugar-top; declare-options-top; declare-globals-top> ast;
      rules(Module : current-file -> ast')

  declare-options-top = Module(id, id, all(try(Options(alltd(declare-options)))))

  declare-globals-top = alltd(declare-globals)

  declare-options:
    Newlines(t) -> <id>
    with
      rules(Options :+ Newlines() -> t)

  declare-options:
    ImportPath(t) -> <id>
    with
      rules(Options :+ ImportPath() -> t)

  declare-options:
    EsvOutput(path) -> <id>
    with
      path' := <norm-output-path> path;
      rules(Options :+ EsvOutput() -> path')

  declare-options:
    SdfOutput(path) -> <id>
    with
      path' := <norm-output-path> path;
      rules(Options :+ SdfOutput() -> path')

  declare-options:
    StrOutput(path) -> <id>
    with
      path' := <norm-output-path> path;
      rules(Options :+ StrOutput() -> path')

  norm-output-path:
    path -> path'
    with
      if is-abspath then
        path' := $[[<ProjectDir>][path]]
      else
        path' := $[[<dirname> <CurrentFile>]/[path]]
      end

  declare-globals:
    template@ TemplateProduction(sort, Template(part*), attrs) ->
      TemplateProduction(sort, Template(part'*), attrs)
    with
      rules(Template :+ sort -> template);
      part'* := <declare-placeholders> part*
    with
      <Declaration> sort
    <+
      // file := <CurrentFile>;
      rules(
        Declaration: sort -> template
        // DeclarationFile: sort -> file
      )
    with
      <alltd(declare-use)> part*

  sort-has-leading-newline =
    bagof-Template;
    ?[_|_];
    all(?TemplateProduction(_, Template([Newline(_)| _]), _))

  sort-has-trailing-newline =
    bagof-Template;
    ?[_|_];
    let trailing-newline =
          at-suffix([Newline(id), ?Layout(_) + ?Indent(_)] <+ [Newline(id)])
    in
      all(?TemplateProduction(_, Template(<trailing-newline>), _))
    end

  declare-placeholders =
       ?[Newline(_), Layout(_), Placeholder(_, _, _, _){}, Newline(_) | _];
       [add-anno(|Leading()), id, add-anno(|Blank()), add-anno(|Trailing()) | id];
       [id, id, id | declare-placeholders]
    <+ ?[Newline(_), Placeholder(_, _, _, _){}, Newline(_) | _];
       [add-anno(|Leading()), add-anno(|Blank()), add-anno(|Trailing()) | id];
       [id, id | declare-placeholders]
    <+ ?[Placeholder(_, Sort(x), _, _){} | _];
       [id | declare-placeholders];
       rules(CanNotBeBlank :+ x -> x)
    <+ ?[_ | _];
       [id | declare-placeholders]
    <+ ?[]

  declare-globals:
    Import(x) -> <id>
    with
      <open-import(
        resolve-import => current-file
      , parse-template-file <+ <debug(!"Parsing failed: ")> x
      , desugar-top; declare-globals-top; ?ast; rules(Module : current-file -> ast)
        <+ <debug(!"Declare-globals-top failed: ")> x
      )> x
   <+
      <debug(!"Import failed: ")> x;
      rules(IsImportFailed: _)

  resolve-import =
    try(
      ?import;
      project-dir := <ProjectDir>;
      current-dir := <dirname> <CurrentFile>;
	    <bagof-Options> ImportPath();
	    fetch-elem(
	      if string-starts-with(|"/") then
          \path -> $[[project-dir][path]/[import].tmpl]\; file-exists
	      else
	        \path -> $[[current-dir]/[path]/[import].tmpl]\; file-exists
	      end
	    );
	    normpath
    )

strategies
  // This part has mostly been copied from the SDF editor!

  declare-globals:
    prod @ prod(lhs, sort, _) -> <id>
    where
      !sort;
      try(?cf(<id>) + ?lex(<id>));
      repeat(?label(_, <id>));
      (?sort(x) + ?parameterized-sort(x, _))
    with
      <Declaration> x
    <+
      // file := <CurrentFile>;
      rules(
        Declaration: x -> prod
        // DeclarationFile: x -> file
      )
    with
      <alltd(declare-use)> lhs

  declare-globals:
    'sorts(_) -> <id>
    with
      alltd(declare-use)

  declare-globals:
    context-free-start-symbols(_) -> <id>
    with
      alltd(declare-use)

  declare-globals:
    lexical-start-symbols(_) -> <id>
    with
      alltd(declare-use)

  declare-globals:
    kernel-start-symbols(_) -> <id>
    with
      alltd(declare-use)

  declare-simple-global:
    sort(x) -> <id>
    with
      rules(Declaration: x -> x)

  declare-use:
    sort(x) -> <id>
    with
      rules(Usage: x -> x)

  declare-use:
    parameterized-sort(x, y) -> <id>
    where
      if !y => [sort(y')]; <is-string> x; <is-string> y' then
        text := ${{x}[[{y'}]]};
        rules(Usage: text -> text)
      end

  declare-use:
    Placeholder(_, Sort(x), _, _) -> <id>
    with
      rules(Usage: x -> x)

  propose-completion:
    sort(COMPLETION(x)) -> [decl*, use*]
    with
      decl* := <all-keys-Declaration> x;
      use*  := <all-keys-Usage> x

  propose-completion:
    NOCONTEXT(COMPLETION(x)) -> [decl*, use*]
    with
      decl* := <all-keys-Declaration> x;
      use*  := <all-keys-Usage> x

  propose-completion:
    Sort(COMPLETION(x)) -> [decl*, use*]
    with
      decl* := <all-keys-Declaration> x;
      use*  := <all-keys-Usage> x
