%% Grammar for the BehaviorTrees language
module BehaviorTrees

imports Common

exports
	
  context-free start-symbols
  
    Start

  lexical syntax

    [a-zA-Z0-9\_\-]+				-> StateID
    [a-zA-Z0-9\_\-]+				-> OpLabel
    [a-zA-Z0-9\_\-\(\)\+\-\*\_]+	-> Value	
    	
  lexical syntax
		
	"+" 							-> OpLabel {reject}
	"-" 							-> OpLabel {reject}
	"--" 							-> OpLabel {reject}
	"+-" 							-> OpLabel {reject}
	"++" 							-> OpLabel {reject}
		   
  lexical restrictions
  
    StateID   						-/- [a-zA-Z0-9\_\-]
    OpLabel   						-/- [a-zA-Z0-9\_\-]
    Value							-/- [a-zA-Z0-9\_\-\(\)\+\-\*\_]
    
    
  context-free syntax
  	
	Requirements? Components? Tree?			-> Start {"Start", scope(Requirement, Component)}
	
	%% Requirements tracibility
	
	"#RT" Requirement*						-> Requirements {"Requirements"}
									
	Requirement@=ID Value					-> Requirement {"Requirement"}
	
	%% Components
	
	Component+								-> Components {"Components"}
	
	"#C" Component@=ID Value Behavior*		-> Component {"Component", scope(State)}
	"#SC" Component@=ID Value Behavior*		-> Component {"SystemComponent", scope(State)}

	%% Behavior

	"#S" State+								-> Behavior {"StateRealisation"}
	%% "#L" State+								-> Behavior {"Selection"}
	%% "#E" State+								-> Behavior {"Event"}
	%% "#G" State+								-> Behavior {"Guard"}
	%% "#II" State+							-> Behavior {"IIEvent"}
	%% "#IO" State+							-> Behavior {"IOEvent"}
	%% "#EI" State+							-> Behavior {"EIEvent"}
	%% "#EO" State+							-> Behavior {"EOEvent"}
	%% "#A" State+								-> Behavior {"Assertion"}

	State@=StateID Value					-> State {"State"}

	%% Tree
	
	"#T" Node 								-> Tree {"Tree"} 
	
	%% Nodes
	
	"_" OpLabel? Op?													-> Node {"EmptyNode"}
	Requirement@ID ReqStatus? Component@ID State@StateID OpLabel? Op?	-> Node	{"Node"}
	
	%% Composition
	
	Node Composition Node			-> Node {"Composition", left}

	";"								-> Composition {"SequentialComp"}
	";;"							-> Composition {"AtomicComp"}
	
	%% Branching

	Node Branch						-> Node {"Branch"}

	"#N" "{" Nodes "}"				-> Branch {"AlternativeBranch"}
	"#P" "{" Nodes "}"				-> Branch {"ParallelBranch"}
	
	Node+							-> Nodes {"Nodes"}
	
	%% Requirements Status
	"+"								-> ReqStatus {"Plus"}
%% 	"-"								-> ReqStatus {"Min"}
%% 	"--"							-> ReqStatus {"DoubleMin"}
%% 	"+-"							-> ReqStatus {"PlusMin"}
%% 	"++"							-> ReqStatus {"DoublePlus"}
	
	%% Operators
	
	"=>"							-> Op {"Op"}
	%% "^"								-> Op {"Op"}
	%% "--"							-> Op {"Op"}
	%% "="								-> Op {"Op"}
	%% "%"								-> Op {"Op"}
	%% "^^"							-> Op {"Op"}
	%% "&"								-> Op {"Op"}
	%% "|"								-> Op {"Op"}	
	
  context-free priorities	
   	{left:
   		Node Composition Node		-> Node
   	}
    >	
    Node Branch						-> Node
      		
	
	
	
	
	
%% 	Common

  lexical syntax
  
    [a-zA-Z][a-zA-Z0-9]* -> ID
    "-"? [0-9]+          -> INT
    
    [\ \t\n\r] -> LAYOUT
    
    [\*]                             -> CommentChar
    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
    
    -> EOF
  
  lexical restrictions
  
    %% Ensure greedy matching for lexicals
  
    CommentChar   -/- [\/]
    INT           -/- [0-9]
    ID            -/- [a-zA-Z0-9\_]
    
    %% EOF may not be followed by any char
    
    EOF           -/- ~[]

  context-free restrictions
  
    %% Ensure greedy matching for comments

    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\/]
    LAYOUT? -/- [\/].[\*]