module emf/sdf-to-ecore
	
imports
	include/SDF
	lib/ecore-signatures
	lib/namespacelib
	emf/namespaces
	emf/projections
	
strategies
	sdf-to-ecore = topdown(try(to-ecore)); create-superclasses; collapse-classes

rules
	to-ecore:
		'module(unparameterized(moduleName), _, exports*)	-> EPackage(properties, children)
	where
		properties := [Name(moduleName)];
		children := <collect-om(?prod(_, _, _))> <collect-om(?context-free-syntax(_))> exports*

	to-ecore:
		prod(lhs, sort, attrs(attributes)) -> EClass(properties, children)
		where 
			constructor := <getfirst(?Constructor(_))> attributes;
			classname := <to-unique-classname> (sort, constructor);
			name := Name(classname);
			properties := <try(add-super-type(|sort))> [name];
			children := <remove-all(?lit(_) + ?ci-lit(_))> lhs	
			
	to-ecore:
		sort(primitiveType) -> EAttribute(properties)
		where 
			name := Name(<first-char-to-lowercase> primitiveType);
			type := Type(<type-to-ecore> primitiveType);
			properties := [name, type]

	to-ecore:
		namespacedef(_, sort(primitiveType)) -> EAttribute(properties)
		where 
			name := Name("identifier");
			type := Type(<type-to-ecore> primitiveType);
			properties := [name, type]

	// to-ecore:
	// 	namespacedef(_, x) -> EReference(properties')
	// 	where 
	// 		properties := <get-properties> x;
	// 		properties' := <map((Name(_) -> Name("name2")) <+ id)> properties
	
	// containment = true 
	to-ecore:
		x -> EReference(properties)
		where
			properties := <get-properties> x

	containment = false
	to-ecore:
		namespaceref2(namespace, _) ->  EReference(properties)
		where
			type := <project-declaration(get-constr|Namespacedef())> namespace;
			name := Name(<first-char-to-lowercase> namespace);
			type' := Type(<conc-strings> ("#//", type));
			containment := Containment(False());
			properties := [name, type', containment]

	//TODO: extract these from lexical syntax
	type-to-ecore:
		"ID" -> EString()
		
	type-to-ecore:
		"INT" -> EInt()


	type-to-ecore:
		"StateID" -> EString()
	type-to-ecore:
		"OpLabel" -> EString()
	type-to-ecore:
		"Value" -> EString()

rules
	
	add-super-type(|sort):
		properties -> properties'
		where
			s := <get-sort> sort;
			not ( <get-unique-declaration(|Production())> s );
			properties' := <conc> (properties, [ESuperType(s)])
			
	to-unique-classname:
		(sort(s), Constructor(c)) -> constructor
		where
			constructor := <un-double-quote> c
		where
			<get-unique-declaration(|Production())> s
			+ not ( <equal> (s, constructor) )
			
	to-unique-classname:
		(sort(s), Constructor(c)) -> <concat-strings> [constructor, "_", <new>]
		where
			constructor := <un-double-quote> c;
			not ( <get-unique-declaration(|Production())> s );
			<equal> (s, constructor)

	get-properties:
		opt(x) -> properties'
		where
			properties := <get-properties> x;
			properties' := <map((LowerBound(1) -> LowerBound(0)) <+ id)> properties

	get-properties:
		sort(s) -> [Name(name), Type(type), LowerBound(1), UpperBound(1), Containment(containment)]
		where
			name := <first-char-to-lowercase> s;
			type := <get-type> s;
			containment := <containment> s
	get-properties:
		iter(sort(s)) -> [Name(name), Type(type), LowerBound(1), UpperBound(-1), Containment(containment)]
		where
			name := <first-char-to-lowercase> s;
			type := <get-type> s;
			containment := <containment> s
	get-properties:
		iter-star(sort(s)) -> [Name(name), Type(type), LowerBound(0), UpperBound(-1), Containment(containment)]
		where
			name := <make-plural> <first-char-to-lowercase> s;
			type := <get-type> s;
			containment := <containment> s
			
	get-type:
		s -> type'
		where 
			<get-unique-declaration(|Production())> s;
			type := <project-declaration(get-constr|Production())> s;
			type' := <conc-strings> ("#//", type)	

	get-type:  // super type
		s -> type
		where 
			<get-declaration(|Production())> s;
			not ( <get-unique-declaration(|Production())> s );
			type := <conc-strings> ("#//", s)

	get-type:
		s -> type
		where 
			not ( <get-declaration(|Production())> s );
			type := EString() //TODO make EInt, EFloat or EString of this depending on the lexical syntax


rules

	first-char-to-lowercase:
		string -> string'	
		where
			(head, tail) := <split-Cons> <explode-string> string;
			head' := <to-lower> head;
			string' := <implode-string> <conc> ([head'], tail)
	
	make-plural:
		string -> string'
		where
			not ( <string-ends-with(|"y")> string );
			string' := <conc-strings> (string, "s")
			
	make-plural:
		string -> string'
		where
			<string-ends-with(|"y")> string;
			init := <implode-string> <init> <explode-string> string;
			string' := <conc-strings> (init, "ies")

	add-dot:
		string -> <conc-strings> (string, ".")


rules
	
	containment:
		namespaceref2(_, _) -> False()
	
	containment:
		sort -> True()
		where
			lhs := <project-declaration(get-lhs|Production())> sort; // what if the sort is not unique? And what if there is a whole sequence of productions that needs to be followed to determine containment?
			<fetch(?namespacedef(_, _))> lhs

	containment:
		sort -> False()
		where not (lhs := <project-declaration(get-lhs|Production())> sort;
			 <fetch(?namespacedef(_, _))> lhs )

rules

	create-superclasses:
		EPackage(properties, classes) -> EPackage(properties, classes')
		where
			non-unique-sorts := <make-set> <remove-all(get-unique-declaration(|Production()))> <project-all-declarations(get-sort|Production())>;
			super-classes := <map(create-superclass)> non-unique-sorts;
			classes' := <conc> (classes, super-classes)
			
	create-superclass:
		sort ->  EClass(properties, children)
		where
			name := Name(sort);
			properties := [name];
			children := []			
			
rules
	
	collapse-classes:
		EPackage(properties, classes) -> EPackage(properties, classes'')
		where
			classes-with-one-ref := <filter(?EClass(_, [EReference(_)]))> classes; //TODO: only take classes that extend another class
			classes' := <diff> (classes, classes-with-one-ref);			
			classes'' := <map(collapse-class(|classes-with-one-ref) <+ id)> classes'
		
	collapse-class(|classes-with-one-ref):
		e@EClass(properties, children) -> EClass(properties', children)
		where
			<fetch(?Name(constructor))> properties;
			namespacedef := <project-declaration(get-namespacedef|Constructor())> constructor;
			class := <fetch-elem(collapse-class(|constructor))> classes-with-one-ref;
			eSuperType := <get-eSuperType> class;
			properties' := <conc> (properties, [ESuperType(eSuperType)])
	
	collapse-class(|sort):
		e@EClass(_, [eReference]) -> e
		where
			namespaceref := <get-reference-type> eReference;
			<equal> (sort, namespaceref)
		
		
			