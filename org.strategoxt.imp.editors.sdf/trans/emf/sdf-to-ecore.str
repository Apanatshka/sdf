module emf/sdf-to-ecore
	
imports
	include/SDF
	lib/ecore-signatures
	
strategies
	
	sdf-to-ecore = to-ecore

rules
	
	to-ecore:
		'module(unparameterized(moduleName), _, exports*)	-> EPackage(properties, classes')
	where
		properties := [Name(moduleName)];
		productions := <collect-om(?prod(_, _, _))> <collect-om(?context-free-syntax(_))> exports*;
		classes := <map(to-ecore)> productions;
		superclasses := <create-superclasses> productions;
		classes' := <remove-all(?[])> <conc>(classes, superclasses)

	to-ecore:
		prod(lhs, sort(s), attributes) -> EClass(properties, structuralFeatures')
		where
			cons := <get-constr> attributes;
			name := Name(cons);
			if <eq> (s, cons) + <eq> (s, "Start") then eSuperType := [] else eSuperType := ESuperType(s) end;
			properties := <remove-all(?[])> [name, eSuperType];
			structuralFeatures := <remove-all(?lit(_) + ?ci-lit(_))> lhs;
			structuralFeatures' := <map(set-name; set-containment; set-bounds; set-structuralFeature)> structuralFeatures

	set-name:
		label(unquoted(name), x) -> (x, [Name(name)])
		
	set-name:
		x -> (x, [])
		where
			not ( <?label(_, _)> x )

	set-containment:
		(namespacedef(_, sort), properties) -> (sort, properties')
		where
			properties' := <remove-all(?[])> <conc> (properties, [Containment(True())])

	set-containment:
		(namespaceref2(_, sort), properties) -> (sort, properties')
		where
			properties' := <remove-all(?[])> <conc> (properties, [Containment(False())])
		
	set-containment:
		(sort, properties) -> (sort, properties')
		where
			not ( <?namespacedef(_, _)> sort + <?namespaceref2(_, _)> sort);
			properties' := <remove-all(?[])> <conc> (properties, [Containment(False())])

	set-bounds:
		(sort(s), properties) -> (s, properties')
		where
			properties' := <conc> (properties, [LowerBound(1), UpperBound(1)])

	set-bounds:
		(iter(sort(s)), properties) -> (s, properties')
		where
			properties' := <conc> (properties, [LowerBound(1), UpperBound(-1)])
	
	set-bounds:
		(iter-star(sort(s)), properties) -> (s, properties')
		where
			properties' := <conc> (properties, [LowerBound(0), UpperBound(-1)])
	
	set-structuralFeature:
		(s, properties) -> eStructuralFeature
		where
			properties' := <add-name> (s, properties);
			
			if
				<int-or-string> s
			then
				type := Type(<int-or-string> s);
				properties'' := <conc> (properties', [type]);
				properties''' := <remove-all(?Containment(_))> properties';
				eStructuralFeature := EAttribute(properties''')
			else
				type := Type(s);
				properties'' := <conc> (properties', [type]);
				eStructuralFeature := EReference(properties'')
			end

	add-name:
		(s, properties) -> properties'
		where
			if <fetch(?Name(_))> properties
			then properties' := properties
			else
				if <fetch(?UpperBound(-1))> properties
				then name := Name(<lower-case; make-plural> s)
				else name := Name(<lower-case> s)
				end;
				properties' := <conc> (properties, [name])
			end

	int-or-string:
		"INT" -> EInt()
		
	int-or-string:
		"ID" -> EString()

rules
	
	create-superclasses:
		productions -> classes
		where
			classes := <make-set> <filter(create-superclass)> productions
			
	create-superclass:
		prod(_, sort(s), attributes) -> EClass([Name(s)], [])
		where
			cons := <get-constr> attributes;
			not ( <eq> (s, cons) );
			not ( <eq> (s, "Start" ))
			
	
rules // Utils

	make-plural:
		string -> string'
		where
			if
				<string-ends-with(|"y")> string
			then 
				init := <implode-string> <init> <explode-string> string;
				string' := <conc-strings> (init, "ies")
			else
				string' := <conc-strings> (string, "s")
			end
			
	get-constr:
		attrs(attributes) -> cons
		where
			Constructor(c) := <getfirst(?Constructor(_))> attributes;
			cons := <un-double-quote> c