module emf/sdf-to-ecore
	
imports
	include/SDF
	trans/emf/ecore-signatures
	lib/attributes
	
strategies
	
	sdf-to-ecore = to-ecore; annotate; normalize

rules
	
	to-ecore:
		'module(unparameterized(moduleName), _, exports*)	-> EPackage(properties, children)
	where
		properties := [Name(moduleName)];
		CF-productions := <collect-om(?prod(_, _, _))> <collect-om(?context-free-syntax(_))> exports*;
		CF-productions' := <map(flatten-prod)> <alltd(rewrite-seq + rewrite-sep)> CF-productions;
		enum-productions := <collect-om(?prod([lit(_)], sort(_), no-attrs()) + ?prod([label(unquoted(_), lit(_))], sort(_), no-attrs()))> <collect-om(?lexical-syntax(_))> exports*;
		enums := <to-enum> enum-productions;
		classes := <map(to-class)> CF-productions';
		abstractClasses := <create-abstract-classes> CF-productions';
		allClasses := <conc> (classes, abstractClasses);
		allClasses' := <set-attributes-and-references(|enums)> allClasses;
		children := <conc> (allClasses', enums)

	to-class:
		prod(lhs, sort(s), attributes) -> EClass(properties', structuralFeatures')
		where
			cons := <fetch-cons-name> attributes;
			name := Name(cons);
			if <eq> (s, cons) + <eq> (s, "Start") then properties := [] else properties := [ESuperType(s)] end;
			properties' := <add-property> (name, properties);
			structuralFeatures := <remove-all(?lit(_) + ?ci-lit(_))> lhs;
			structuralFeatures' := <map(set-user-defined-name; def-ref-containment; set-bounds; set-name; set-structuralFeature)> structuralFeatures

	set-user-defined-name:
		label(unquoted(name), x) -> (x, [Name(name)])
		
	set-user-defined-name:
		x -> (x, [])
		where
			not ( <?label(_, _)> x )
	
	def-ref-containment:
		(namespacedef(_, sort), properties) -> (sort, properties')
		where
			containment := Containment(True());
			identifier := Identifier(True());
			properties' := <add-properties> ([containment, identifier], properties)
	
	def-ref-containment:
		(namespaceref2(namespace, sort), properties) -> (sort, properties')
		where
			name := Name(<lower-case> namespace);
			type := Type(namespace);
			containment := Containment(False());
			properties' := <add-properties> ([name, type, containment], properties)
		
	def-ref-containment:
		(sort, properties) -> (sort, properties')
		where
			not ( <?namespacedef(_, _)> sort + <?namespaceref2(_, _)> sort);
			properties' := <add-property> (Containment(True()), properties)

	set-bounds:
		(opt(sort(s)), properties) -> (s, properties')
		where
			properties' := <add-properties> ([LowerBound(0), UpperBound(1)], properties)

	set-bounds:
		(sort(s), properties) -> (s, properties')
		where
			properties' := <add-properties> ([LowerBound(1), UpperBound(1)], properties)

	set-bounds:
		(iter(sort(s)), properties) -> (s, properties')
		where
			properties' := <add-properties> ([LowerBound(1), UpperBound(-1)], properties)
	
	set-bounds:
		(iter-star(sort(s)), properties) -> (s, properties')
		where
			properties' := <add-properties> ([LowerBound(0), UpperBound(-1)], properties)
	
	set-name:
		(s, properties) -> (s, properties')
		where
			if <fetch(?UpperBound(-1))> properties
			then name := Name(<lower-case; make-plural> s)
			else name := Name(<lower-case> s)
			end;
			properties' := <add-property> (name, properties)

	set-structuralFeature:
		(s, properties) -> EStructuralFeature(s, properties)

	set-attributes-and-references(|enums):
		classes -> classes'
		where
			classnames := <map(fetch-name)> classes;
			enumnames := <map(fetch-name)> enums;
			classes' := <alltd(set-attributes-and-references(|classnames, enumnames))> classes

	set-attributes-and-references(|classnames, enumnames):
		e@EStructuralFeature(s, properties) -> EAttribute(properties'')
		where
			<is-attribute(|classnames, enumnames)> e;
			properties' := <remove-all(?Containment(_))> properties;
			
			if <is-primitive-type(|classnames, enumnames)> s
			then type := <to-primitive-type> s
			else type := Type(s)
			end;
				
			properties'' := <add-property> (type, properties')
			
	set-attributes-and-references(|classnames, enumnames):
		e@EStructuralFeature(s, properties) -> EReference(properties')
		where
			not ( <is-attribute(|classnames, enumnames)> e );
			type := Type(s);
			properties' := <add-property> (type, properties)

	is-attribute(|classnames, enumnames):
		e@EStructuralFeature(s, properties) -> e
		where
			not ( <fetch(?Containment(False()))> properties );
			<is-primitive-type(|classnames, enumnames)> s

	is-primitive-type(|classnames, enumnames):
		s -> s
		where
			not ( <fetch(?s)> classnames + <fetch(?s)> enumnames )

rules

	to-primitive-type:
		s -> Primitive(t)
		where
			eDataTypes := ["EBigDecimal", "EBigInteger", "EBoolean", "EBooleanObject", "EByte", "EByteArray", "EByteObject", "EChar", "ECharacterObject", "EDate", "EDiagnosticChain", "EDouble", "EDoubleObject", "EEList", "EEnumeration", "EFeaturemap", "EFeaturemapEnty", "EFloat", "EFloatObject", "EInt", "EIntegerObject", "EInvocationTargetException", "EJavaClass", "EJavaObject", "ELong", "ELongObject", "EMap", "EResource", "EResourceSet", "EShort", "EShortObject", "EString", "ETreeIterator"];
			if not ( t := <known-type> s )
			then 
				if not ( t := <fetch-elem(isEDataType(|s))> eDataTypes )
				then t := "EString" // default
				end
			end
	
	known-type: "INT"	-> "EInt"
	known-type: "ID"	-> "EString"

	isEDataType(|s):
		t -> t
		where
			s' := <lower-case> s;
			t' := <lower-case> t
		where
			<eq> ( s', t') + <string-ends-with(|s')> t' // with or wihtout 'E'

rules
	
	create-abstract-classes:
		productions -> classes
		where
			classes := <make-set> <filter(create-abstract-class)> productions
			
	create-abstract-class:
		prod(_, sort(s), attributes) -> EClass([Name(s), Abstract(True())], [])
		where
			cons := <fetch-cons-name> attributes;
			not ( <eq> (s, cons) );
			not ( <eq> (s, "Start" ))
			
rules
	
	rewrite-seq:
		s@seq(a, b) -> sequence
		where
			sequence := <remove-literals> s
			
	rewrite-seq:
		opt(s@seq(a, b)) -> result	
		where
			sequence := <remove-literals> s;
			result := <map(alltd(make-opt))> sequence
			
	rewrite-seq:
		iter(s@seq(a, b)) -> result
		where
			sequence := <remove-literals> s;
			result := <map(alltd(make-iter))> sequence	

	rewrite-seq:
		iter-star(s@seq(a, b)) -> result
		where
			sequence := <remove-literals> s;
			result := <map(alltd(make-iter-star))> sequence

	remove-literals:
		seq(a, b) -> result
		where
			sequence := <conc> ([a], b);
			result := <remove-all(?lit(_))> sequence
	
	make-opt: sort(s) -> opt(sort(s))
	make-iter: sort(s) -> iter(sort(s))
	make-iter-star: sort(s) -> iter-star(sort(s))

rules //extract non-terminal from a seperator
	
	rewrite-sep:
		iter-sep(non-terminal, _) -> result
		where
			result := <alltd(make-iter)> non-terminal
	
	rewrite-sep:
		iter-star-sep(non-terminal, _) -> result
		where
			result := <alltd(make-iter-star)> non-terminal
			
rules // utils

	// add property with constructor cons to list if list doesn't contain a property with constructor cons yet 
	add-property:
		(property, list) -> list'
		where
			cons := <get-constructor> property;
			if 	<fetch(<eq> (cons, <get-constructor>))> list
			then list' := list
			else list' := <conc> (list, [property])
			end
			
	add-properties:
		(properties, list) -> list'
		where
			list' := <foldl(add-property)> (properties, list)

	make-plural:
		string -> string'
		where
			if
				<string-ends-with(|"y")> string
			then 
				init := <implode-string> <init> <explode-string> string;
				string' := <conc-strings> (init, "ies")
			else
				string' := <conc-strings> (string, "s")
			end

	flatten-prod:
		prod(lhs, s, attrs) -> prod(lhs', s, attrs)
		where
			lhs' := <flatten-list> lhs

rules
	
	to-enum:
		enum-productions -> enums
		where
			enum-names := <collect-om(fetch-enum-name)> enum-productions;
			enums := <map(create-enum(|enum-productions))> enum-names
	
	create-enum(|enum-productions):
		enum-name -> EEnum(enum-name, enum-literals)
		where
			enum-literals := <collect-om(to-enum-literal(|enum-name))> enum-productions
			
	fetch-enum-name:
		prod(_, sort(enum-name), _) -> enum-name
		
	to-enum-literal(|enum-name):
		prod([lit(enum-literal)], sort(enum-name), _) -> ENumLiteral(<un-double-quote> enum-literal, <un-double-quote> enum-literal)

	to-enum-literal(|enum-name):
		prod([label(unquoted(enum-literal-name), lit(enum-literal))], sort(enum-name), _) -> ENumLiteral(<un-double-quote> enum-literal, enum-literal-name)

	is-abstract:
		e@EClass(properties, _) -> e
		where
			<fetch(?Abstract(True()))> properties
	
	is-subclass:
		e@EClass(properties, _) -> e
		where
			<fetch(?ESuperType(_))> properties
	
	fetch-name:
		EClass(properties, _) -> name
		where
			<fetch(?Name(name))> properties
	
	fetch-name:
		EAttribute(properties) -> name
		where
			<fetch(?Name(name))> properties

	fetch-name:
		EReference(properties) -> name
		where
			<fetch(?Name(name))> properties	
	
	fetch-name:
		EEnum(name, _) -> name
	
	fetch-type:
		EAttribute(properties) -> type
		where
			<fetch(?Type(type))> properties

	fetch-type:
		EReference(properties) -> type
		where
			<fetch(?Type(type))> properties	
	
	is-super-type(|abstractClass):
		e@EClass(properties, _) -> e
		where
			<fetch(?ESuperType(superType))> properties;
			abstractClassname := <fetch-name> abstractClass;
			<eq> (superType, abstractClassname)
			
	fetch-subclasses:
		(abstractClass, classes) -> subclasses
		where
			subclasses := <filter(is-super-type(|abstractClass))> classes
	
	has-structural-feature(|sf):
		e@EClass(_, children) -> e
		where
			<?EAttribute(_) + ?EReference(_)> sf;
			<fetch(?sf)> children
			
rules
	
	annotate:
		EPackage(properties, classes) -> EPackage(properties, classes')
		where
			classes' := <map(try(annotate))> classes
	
	annotate:
		EClass(properties, structuralFeatures) -> EClass(properties, children)
		where
			not ( <fetch(?Abstract(True()))> properties );
			detailEntries := <map(to-detail-entry(|structuralFeatures))> structuralFeatures;
			children := <conc> (structuralFeatures, [EAnnotation("StrategoTerm.index", detailEntries)])
	
	to-detail-entry(|structuralFeatures):
		e@EAttribute(properties) -> detailsEntry
		where
			detailsEntry := <to-detail-entry(|structuralFeatures)> (e, properties)
			
	to-detail-entry(|structuralFeatures):
		e@EReference(properties) -> detailsEntry
		where
			detailsEntry := <to-detail-entry(|structuralFeatures)> (e, properties)
	
	to-detail-entry(|structuralFeatures):
		(e, properties) -> DetailsEntry(index, propertyName)
		where
			index := <int-to-string> <subti> (<get-index> (e, structuralFeatures), 1);
			<fetch(?Name(propertyName))> properties
			
rules
	
	normalize:
		EPackage(properties, children) -> EPackage(properties, children')
			where
				enums := <filter(?EEnum(_, _))> children;
				standardClasses := <remove-all(is-abstract + is-subclass + ?EEnum(_, _))> children;
				abstractClasses := <filter(is-abstract)> children;
				normalizedClasses := <flatten-list> <map(normalize(|children))> abstractClasses;
				children' := <concat> [standardClasses, normalizedClasses, enums]
	
	normalize(|classes):
		e@EClass(properties, _) -> normalizedClasses
		where
			subclasses := <fetch-subclasses> (e, classes);
			EClass(_, features) := <index(|1)> subclasses;
			commonStructuralFeatures := <filter(isCommonStructuralFeature(|subclasses))> features;
			normalizedSubclasses := <map(remove-features(|commonStructuralFeatures))> subclasses;
			normalizedAbstractClass := EClass(properties, commonStructuralFeatures);
			normalizedClasses := <conc> ([normalizedAbstractClass], normalizedSubclasses)
	
	isCommonStructuralFeature(|subclasses):
		sf -> sf
		where
			<map(has-structural-feature(|sf))> subclasses

	remove-features(|commonStructuralFeatures):
		EClass(properties, features) -> EClass(properties, features')
		where
			features' := <diff> (features, commonStructuralFeatures)
		