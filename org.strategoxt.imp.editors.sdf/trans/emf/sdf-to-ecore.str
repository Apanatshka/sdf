module emf/sdf-to-ecore
	
imports
	include/SDF
	lib/ecore-signatures
	
strategies
	
	sdf-to-ecore = to-ecore

rules
	
	to-ecore:
		'module(unparameterized(moduleName), _, exports*)	-> EPackage(properties, classes')
	where
		properties := [Name(moduleName)];
		productions := <collect-om(?prod(_, _, _))> <collect-om(?context-free-syntax(_))> exports*;
		classes := <map(to-ecore)> productions;
		superclasses := <create-superclasses> productions;
		classes' := <remove-all(?[])> <conc>(classes, superclasses)

	to-ecore:
		prod(lhs, sort(s), attributes) -> EClass(properties, structuralFeatures')
		where
			cons := <get-constr> attributes;
			name := Name(cons);
			if <eq> (s, cons) then eSuperType := [] else eSuperType := ESuperType(s) end;
			properties := <remove-all(?[])> [name, eSuperType];
			structuralFeatures := <remove-all(?lit(_) + ?ci-lit(_))> lhs;
			structuralFeatures' := <map(set-containment; set-bounds; set-structuralFeature)> structuralFeatures

	set-containment:
		namespacedef(_, sort) -> (sort, [Containment(True())])

	set-containment:
		namespaceref2(_, sort) -> (sort, [Containment(False())])
		
	set-containment:
		sort -> (sort, [Containment(True())])
			where
				not ( <?namespacedef(_, _)> sort + <?namespaceref2(_, _)> sort)

	set-bounds:
		(sort(s), properties) -> (s, properties')
		where
			properties' := <conc> (properties, [LowerBound(1), UpperBound(1)])

	set-bounds:
		(iter(sort(s)), properties) -> (s, properties')
		where
			properties' := <conc> (properties, [LowerBound(1), UpperBound(-1)])
	
	set-bounds:
		(iter-star(sort(s)), properties) -> (s, properties')
		where
			properties' := <conc> (properties, [LowerBound(0), UpperBound(-1)])
	
	set-structuralFeature:
		(s, properties) -> eStructuralFeature
		where
			name := Name(<first-char-to-lowercase> s);
			if
				<int-or-string> s
			then
				type := Type(<int-or-string> s);
				properties' := <conc> (properties, [name, type]);
				properties'' := <remove-all(?Containment(_))> properties';
				eStructuralFeature := EAttribute(properties'')
			else
				type := Type(s);
				properties'' := <conc> (properties, [name, type]);
				eStructuralFeature := EReference(properties'')
			end

	int-or-string:
		"INT" -> EInt()
		
	int-or-string:
		"ID" -> EString()

rules
	
	create-superclasses:
		productions -> classes
		where
			classes := <make-set> <filter(create-superclass)> productions
			
	create-superclass:
		prod(_, sort(s), attributes) -> EClass([Name(s)], [])
		where
			cons := <get-constr> attributes;
			not ( <eq> (s, cons) )
			
	
rules // Utils

	first-char-to-lowercase:
		string -> string'	
		where
			(head, tail) := <split-Cons> <explode-string> string;
			head' := <to-lower> head;
			string' := <implode-string> <conc> ([head'], tail)
	
	make-plural:
		string -> string'
		where
			if
				<string-ends-with(|"y")> string
			then 
				init := <implode-string> <init> <explode-string> string;
				string' := <conc-strings> (init, "ies")
			else
				string' := <conc-strings> (string, "s")
			end
			
	get-constr:
		attrs(attributes) -> cons
		where
			Constructor(c) := <getfirst(?Constructor(_))> attributes;
			cons := <un-double-quote> c