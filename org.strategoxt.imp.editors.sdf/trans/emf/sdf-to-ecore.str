module emf/sdf-to-ecore
	
imports
	include/SDF
	lib/ecore-signatures
	lib/attributes
	
strategies
	
	sdf-to-ecore = to-ecore

rules
	
	to-ecore:
		'module(unparameterized(moduleName), _, exports*)	-> EPackage(properties, classes')
	where
		properties := [Name(moduleName)];
		productions := <collect-om(?prod(_, _, _))> <collect-om(?context-free-syntax(_))> exports*;
		classes := <map(to-ecore)> productions;
		superclasses := <create-superclasses> productions;
		classes' := <remove-all(?[])> <conc>(classes, superclasses)

	to-ecore:
		prod(lhs, sort(s), attributes) -> EClass(properties', structuralFeatures')
		where
			cons := <fetch-cons-name> attributes;
			name := Name(cons);
			if <eq> (s, cons) + <eq> (s, "Start") then properties := [] else properties := [ESuperType(s)] end;
			properties' := <add-property> (name, properties);
			structuralFeatures := <remove-all(?lit(_) + ?ci-lit(_))> lhs;
			structuralFeatures' := <map(set-name; set-containment; set-bounds; set-structuralFeature)> structuralFeatures

	set-name:
		label(unquoted(name), x) -> (x, [Name(name)])
		
	set-name:
		x -> (x, [])
		where
			not ( <?label(_, _)> x )

	set-containment:
		(namespacedef(_, sort), properties) -> (sort, properties')
		where
			properties' := <add-property> (Containment(True()), properties)
	
	// for namespaceref2, also set name and type
	set-containment:
		(namespaceref2(namespace, sort), properties) -> (sort, properties')
		where
			name := Name(<lower-case> namespace);
			type := Type(namespace);
			containment := Containment(False());
			properties' := <add-properties> ([name, type, containment], properties)
		
	set-containment:
		(sort, properties) -> (sort, properties')
		where
			not ( <?namespacedef(_, _)> sort + <?namespaceref2(_, _)> sort);
			properties' := <add-property> (Containment(False()), properties)

	set-bounds:
		(opt(sort(s)), properties) -> (s, properties')
		where
			properties' := <add-properties> ([LowerBound(0), UpperBound(1)], properties)

	set-bounds:
		(sort(s), properties) -> (s, properties')
		where
			properties' := <add-properties> ([LowerBound(1), UpperBound(1)], properties)

	set-bounds:
		(iter(sort(s)), properties) -> (s, properties')
		where
			properties' := <add-properties> ([LowerBound(1), UpperBound(-1)], properties)
	
	set-bounds:
		(iter-star(sort(s)), properties) -> (s, properties')
		where
			properties' := <add-properties> ([LowerBound(0), UpperBound(-1)], properties)
	
	set-structuralFeature:
		(s, properties) -> eStructuralFeature
		where			
			if <fetch(?UpperBound(-1))> properties
			then name := Name(<lower-case; make-plural> s)
			else name := Name(<lower-case> s)
			end;
			properties' := <add-property> (name, properties);
			
			if
				<int-or-string> s
			then
				type := Type(<int-or-string> s);
				properties'' := <add-property> (type, properties');
				properties''' := <remove-all(?Containment(_))> properties'';
				eStructuralFeature := EAttribute(properties''')
			else
				type := Type(s);
				properties'' := <add-property> (type, properties');
				eStructuralFeature := EReference(properties'')
			end

	int-or-string:
		"INT" -> EInt()
		
	int-or-string:
		"ID" -> EString()

rules
	
	create-superclasses:
		productions -> classes
		where
			classes := <make-set> <filter(create-superclass)> productions
			
	create-superclass:
		prod(_, sort(s), attributes) -> EClass([Name(s)], [])
		where
			cons := <fetch-cons-name> attributes;
			not ( <eq> (s, cons) );
			not ( <eq> (s, "Start" ))
			
	
rules // utils

	// add property with constructor cons to list if list doesn't contain a property with constructor cons yet 
	add-property:
		(property, list) -> list'
		where
			cons := <get-constructor> property;
			if 	<fetch(<eq> (cons, <get-constructor>))> list
			then list' := list
			else list' := <conc> (list, [property])
			end
			
	add-properties:
		(properties, list) -> list'
		where
			list' := <foldl(add-property)> (properties, list)

	make-plural:
		string -> string'
		where
			if
				<string-ends-with(|"y")> string
			then 
				init := <implode-string> <init> <explode-string> string;
				string' := <conc-strings> (init, "ies")
			else
				string' := <conc-strings> (string, "s")
			end
			