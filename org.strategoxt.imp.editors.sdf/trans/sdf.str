module sdf

imports
  libstratego-lib
  libstratego-sdf
  libstratego-sglr
  libstrc
  analysis

rules

  // TODO: Report proper SDF errors  

  editor-analyze:
    (ast, path, project-path) -> (errors, warnings, [])
    with
      // Ensure all dynamic rules are properly scoped
      try(dr-scope-all-end);
      dr-scope-all-start
    with
      analyze-ast;
      errors   := <collect(?context-free-syntax(<collect-om(context-free-syntax-error)>))> ast;
      // We only collect-om since we don't want inner warning dupes
      warnings := <collect(?context-free-syntax(<collect-om(context-free-syntax-warning)>))> ast

  editor-complete:
    (node, position, ast, path, project-path) -> proposals
    where
      proposals := <propose-completion <+ ![]> node
 
  editor-resolve:
    (sort(x), position, ast, path, project-path) -> target
    where
      target := <Declaration> x

  override pp-sdf-string = fail // ensure compiler doesn't blow up

rules
  
  context-free-syntax-warning:
    prod(p, s, a*) -> (target, $[Missing {cons("Label")} attribute to label the abstract syntax])
    where
      not(<collect(?sort(_))> p => [_])
    ; if !a* => attrs(a'*) then
        not(<one(term(default(appl(unquoted("cons"), [id]))))> a'*)
      ; not(<one(term(default(appl(unquoted("bracket" + "reject"), []))))> a'*)
      ; not(<one(reject())> a'*)
      ; not(!s; (sort("Keyword") + sort("\"Keyword\""))) 
      ; target := a*
      else
        target := s
      end
   
  context-free-syntax-warning:
    alt(x, y) -> (<id>, $[The | construct is deprecated: instead of A|B->C use A->C B->C])

  context-free-syntax-warning:
    seq(_, _) -> (<id>, $[Extract sequences of patterns to separate productions to ensure acceptable abstract syntax])
    where
      occurrences(sort(id)) => 1

  context-free-syntax-warning:
    seq(_, _) -> (<id>, $[Extract sequences of patterns to separate productions to ensure acceptable abstract syntax])
    where
      occurrences(sort(id)) => 1

  // StrategoXT/817
  context-free-syntax-error:
    < ?iter-star(s) + ?iter(s) + ?iter-star-sep(s,_) + ?iter-sep(s,_)> ->
    (s, $[At least one non-terminal expected])
    where
      occurrences(sort(id)) => 0

  context-free-syntax-warning:
    [sort(x), bad @ iter-star(seq(lit(sep), [sort(x)])) | _] ->
    (<id>, $[Use {[x] [sep]}+ instead for [sep]-separated lists])

  context-free-syntax-warning:
    [iter-star(seq(sort(x), [lit(sep)])), sort(x) | _] ->
    (<id>, $[Use {[x] [sep]}+ instead for [sep]-separated lists])

  context-free-syntax-warning:
    [opt(sort(x)), iter-star(seq(lit(sep), [sort(x)])) | _] ->
    (<id>, $[Use {[x] [sep]}* instead for [sep]-separated lists])

  context-free-syntax-warning:
    [iter-star(seq(sort(x), [lit(sep)])), opt(sort(x)) | _] ->
    (<id>, $[Use {[x] [sep]}* instead for [sep]-separated lists])

  context-free-syntax-warning:
    [iter-star(seq(sort(x), [lit(sep)])), opt(sort(x)) | _] ->
    (<id>, $[Use {[x] [sep]}* instead for [sep]-separated lists])
  
  context-free-syntax-warning:
    iter-sep(_, bad @ sort(_)) -> (bad, "Non-terminal used as a list separator (use round braces for grouping non-terminals)") 
  
  context-free-syntax-warning:
    iter-star-sep(_, bad @ sort(_)) -> (bad, "Non-terminal used as a list separator (use round braces for grouping non-terminals)") 

rules

  generate-pp-rules:
    (selected, position, ast, path, project-path) -> (filename, result)
    where
      filename  := <guarantee-extension(|"pp")> path;
      selected' := <add-context; sdf-desugar> selected;
      result    := <ppgenerate; pp-pp-table> selected'
    <+
      fatal-err(|$[Could not generate pretty printer rules for this selection.
                   Only productions with {cons()} attributes are supported.])
  
  generate-rtg:
    (selected, position, ast, path, project-path) -> (filename, result)
    where
      filename  := <guarantee-extension(|"rtg")> path;
      selected' := <add-context; sdf-desugar> selected;
      result    := <core-rtg2sig; pp-stratego-string> selected'
    <+
      fatal-err(|$[Could not generate abstract syntax signatures for this selection.
                   Only productions with {cons()} attributes are supported.])
  
  generate-aterm:
    (selected, position, ast, path, project-path) -> (filename, selected)
    where
      filename  := <guarantee-extension(|"aterm")> path
  
  add-context =
    if not(oncetd(?context-free-syntax(_))) then
      if is-list then
        !context-free-syntax(<id>)
      else
        !context-free-syntax([<id>])
      end
    end

rules // External tools not included in the standard libraries

  ppgenerate =
    <call> ("org.strategoxt.tools.ppgenerate", [<id>])

  core-rtg2sig =
    <call> ("org.strategoxt.tools.core-rtg2sig", [<id>])

  pp-pp-table =
    <call> ("org.strategoxt.tools.pp-pp-table", [<id>])
  
  sdf-desugar =
    <call> ("org.strategoxt.tools.sdf-desugar", [<id>])
