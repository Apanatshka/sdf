/*
This file implements \n as LAYOUT, but still allows it to be used as e.g.
statement separator in other productions, without resulting in ambiguities.

This is done by declaring all whitespace characters except \n as LAYOUT, and
allowing \n as LAYOUT _only_ as part of the special "LineBreak" sort, which
greedily eats all layout (including any subsequent \n) after the initial \n.

As such, whitespace at the end of a line is parsed as typical LAYOUT.
When the \n is encountered the only valid parse is to treat all subsequent
whitespace (including empty lines) as a LineBreak, which has an injection
into LAYOUT.

If there is a \n required by a production, then the first \n _must_ be
parsed as the \n required by the production (and the second \n, if any,
starts a LineBreak sort), as there is no way to "escape" from the greedy
LineBreak sort otherwise.

Unfortunately this does not always work. Because LAYOUT? may be followed by
a \n there WILL be an ambiguity everytime the LAYOUT token is to be injected
in one of multiple LAYOUT?-"holes" in the CF grammar. There is no way to
constrain which "hole" is used apart from forbidding LAYOUT? to be followed
by a \n. But then semantic \n will always be eaten by any preceding LAYOUT?,
nullifying the entire point of this file...

Since this ambiguity appears to always be of a simple amb([x, x]) form,
a Stratego-based disambiguator has been employed in this project to remove
those ambiguities: amb([x, x]) -> x
*/

module Layout

lexical syntax
  [\ \t\r] -> LayoutChar
  LayoutChar -> LAYOUT

  "\n" ("\n" | LayoutChar)* -> LineBreak
  LineBreak -> LAYOUT

  "//" ~[\n]* -> Comment
  Comment -> LayoutChar

lexical restrictions
  LineBreak -/- [\ \t\n\r]
  LineBreak -/- [\/].[\/]
  Comment   -/- ~[\n]

context-free restrictions
  LAYOUT? -/- [\ \t\r]
  LAYOUT? -/- [\/].[\/]
